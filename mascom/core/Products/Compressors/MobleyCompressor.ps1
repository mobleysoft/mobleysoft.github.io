function TokenizeText {param ([string]$PayloadFilePath) if (-Not (Test-Path $PayloadFilePath)) {Write-Host "Error: Payload file not found."; return $null}; $text = Get-Content -Path $PayloadFilePath -Raw; $tokens = $text.ToCharArray(); return $tokens}
function GetTokenFrequencies {param ([string[]]$Tokens) if (-Not $Tokens) {Write-Host "Error: Tokens are null."; return $null}; $frequencyMap = @{}; foreach ($token in $Tokens) {if ($frequencyMap.ContainsKey($token)) {$frequencyMap[$token]++} else {$frequencyMap[$token] = 1}} return $frequencyMap}
function AssignHarmonics {param ([hashtable]$FrequencyMap) if (-Not $FrequencyMap) {Write-Host "Error: Frequency map is null."; return $null}; $sortedTokens = $FrequencyMap.GetEnumerator() | Sort-Object -Property Value -Descending; $harmonicMap = @{}; $n = 1; foreach ($entry in $sortedTokens) {$harmonicMap[$entry.Key] = $n; $n++} return $harmonicMap}
function CalculatePhaseOffsets {param ([string[]]$Tokens, [hashtable]$HarmonicMap) if (-Not $Tokens -or -Not $HarmonicMap) {Write-Host "Error: Invalid Payloads to CalculatePhaseOffsets."; return $null}; $phiMap = @{}; $position = 0; foreach ($token in $Tokens) {$harmonic = $HarmonicMap[$token]; $phiMap[$harmonic] = [math]::Sin(2 * [math]::PI * $harmonic * $position / $Tokens.Length); $position++} return $phiMap}
function CompressText {param ([string]$PayloadFilePath, [string]$OutputFilePath) if (-Not (Test-Path $PayloadFilePath)) {Write-Host "Error: Payload file not found."; return}; Write-Host "Starting compression..."; $tokens = TokenizeText -PayloadFilePath $PayloadFilePath; if (-Not $tokens) {Write-Host "Error: Tokenization failed."; return}; Write-Host "Calculating token frequencies..."; $frequencyMap = GetTokenFrequencies -Tokens $tokens; if (-Not $frequencyMap) {Write-Host "Error: Frequency calculation failed."; return}; Write-Host "Assigning harmonics to tokens..."; $harmonicMap = AssignHarmonics -FrequencyMap $frequencyMap; if (-Not $harmonicMap) {Write-Host "Error: Harmonic assignment failed."; return}; Write-Host "Calculating phase offsets..."; $phiMap = CalculatePhaseOffsets -Tokens $tokens -HarmonicMap $harmonicMap; if (-Not $phiMap) {Write-Host "Error: Phase offset calculation failed."; return}; Write-Host "Saving compressed parameters..."; $output = @{a = 0.9; b = 2.0; phiMap = $phiMap; harmonicMap = $harmonicMap}; $json = $output | ConvertTo-Json -Depth 2; Set-Content -Path $OutputFilePath -Value $json; Write-Host "Compression complete. Parameters saved to $OutputFilePath"}
function DecompressText {param ([string]$PayloadFilePath, [string]$OutputFilePath) if (-Not (Test-Path $PayloadFilePath)) {Write-Host "Error: Compressed file not found."; return}; Write-Host "Starting decompression..."; $Payload = Get-Content -Path $PayloadFilePath -Raw | ConvertFrom-Json; $phiMap = $Payload.phiMap; $harmonicMap = $Payload.harmonicMap; if (-Not $phiMap -or -Not $harmonicMap) {Write-Host "Error: Invalid compressed file format."; return}; $tokens = @{}; foreach ($key in $harmonicMap.Keys) {$tokens[$harmonicMap[$key]] = $key} Write-Host "Reconstructing original dataset..."; $output = ($phiMap.GetEnumerator() | Sort-Object -Property Key).Value -join ''; Set-Content -Path $OutputFilePath -Value $output; Write-Host "Decompression complete. Dataset saved to $OutputFilePath"}
function MonitorResourceUsage {param ([ScriptBlock]$ScriptBlock) $startMemory = (Get-Process -Id $PID).WorkingSet64; $startTime = Get-Date; $ScriptBlock.Invoke(); $endMemory = (Get-Process -Id $PID).WorkingSet64; $endTime = Get-Date; $elapsedTime = $endTime - $startTime; Write-Host "Memory Used: $([math]::Round(($endMemory - $startMemory) / 1MB, 2)) MB"; Write-Host "Elapsed Time: $([math]::Round($elapsedTime.TotalSeconds, 2)) seconds"}
function TestCompressionSystem {Write-Host "Testing compression on enwik9..."; $testPayloadPath = "C:\Users\Owner\mascom\Core\Knowledge\enwik9\enwik9.txt"; $compressedPath = "compressed_output.json"; $decompressedPath = "decompressed_output.txt"; Write-Host "Compressing and decompressing..."; MonitorResourceUsage {CompressText -PayloadFilePath $testPayloadPath -OutputFilePath $compressedPath}; MonitorResourceUsage {DecompressText -PayloadFilePath $compressedPath -OutputFilePath $decompressedPath}; $original = Get-Content -Path $testPayloadPath -Raw; $decompressed = Get-Content -Path $decompressedPath -Raw; $originalSize = (Get-Item $testPayloadPath).Length; $compressedSize = (Get-Item $compressedPath).Length; Write-Host "Original Size: $originalSize bytes"; Write-Host "Compressed Size: $compressedSize bytes"; if ($original -eq $decompressed) {Write-Host "Test passed: Original and decompressed files match."; $compressionRatio = [math]::Round(($compressedSize / $originalSize) * 100, 2); Write-Host "Compression Ratio: $compressionRatio%"; $prizePotential = [math]::Round(500000 * (1 - ($compressedSize / $originalSize)), 2); Write-Host "Potential Prize Earnings: â‚¬$prizePotential"; Write-Host "Generating submission components..."; $submissionFolder = "C:\Users\Owner\mascom\Core\Knowledge\enwik9\submission"; if (-not (Test-Path $submissionFolder)) {New-Item -ItemType Directory -Path $submissionFolder | Out-Null}; Copy-Item -Path $compressedPath -Destination "$submissionFolder\archive9.bhm"; $sourceCodePath = "$submissionFolder\source_code.zip"; Compress-Archive -Path "$MyInvocation.MyCommand.Path" -DestinationPath $sourceCodePath; Set-Content -Path "$submissionFolder\README.txt" -Value "Submission Instructions:\n\nRun archive9.bhm with decomp9.exe to reproduce the dataset.\n\nSystem Details:\nProcessor: $(Get-WmiObject Win32_Processor | Select-Object -ExpandProperty Name)\nMemory: $(Get-WmiObject Win32_ComputerSystem | Select-Object -ExpandProperty TotalPhysicalMemory) bytes\nOperating System: $(Get-WmiObject Win32_OperatingSystem | Select-Object -ExpandProperty Caption)"; Write-Host "Generating executables..."; $scriptPath = "$MyInvocation.MyCommand.Path"; $compExe = "$submissionFolder\comp9.exe"; $decompExe = "$submissionFolder\decomp9.exe"; if (Get-Command ps2exe.ps1 -ErrorAction SilentlyContinue) {ps2exe.ps1 -PayloadFile $scriptPath -outputFile $compExe; ps2exe.ps1 -PayloadFile $scriptPath -outputFile $decompExe; Write-Host "Executables generated successfully."} else {Write-Host "Error: PS2EXE module not installed. Skipping executable generation."}; Compress-Archive -Path "$submissionFolder\*" -DestinationPath "$submissionFolder\final_submission.zip"; Write-Host "Submission components saved to $submissionFolder\final_submission.zip"} else {Write-Host "Test failed: Original and decompressed files do not match."}}
TestCompressionSystem
