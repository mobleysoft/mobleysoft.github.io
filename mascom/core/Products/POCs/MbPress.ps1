$TestMode = $true
function TokenizeText {param ([string]$InputFilePath) if (-Not (Test-Path $InputFilePath)) {Write-Host "Error: Input file not found."; return $null}; $text = Get-Content -Path $InputFilePath -Raw; if ($TestMode) {$tokens = $text.ToCharArray()[0..999]} else {$tokens = $text.ToCharArray()}; return $tokens}
function GetTokenFrequencies {param ([string[]]$Tokens) if (-Not $Tokens) {Write-Host "Error: Tokens are null."; return $null}; $frequencyMap = @{}; foreach ($token in $Tokens) {if ($frequencyMap.ContainsKey($token)) {$frequencyMap[$token]++} else {$frequencyMap[$token] = 1}} return $frequencyMap}
function AssignHarmonics {param ([hashtable]$FrequencyMap) if (-Not $FrequencyMap) {Write-Host "Error: Frequency map is null."; return $null}; $sortedTokens = $FrequencyMap.GetEnumerator() | Sort-Object -Property Value -Descending; $harmonicMap = @{}; $n = 1; foreach ($entry in $sortedTokens) {$harmonicMap[$entry.Key] = $n; $n++} Write-Host "Harmonic Map:"; $harmonicMap.GetEnumerator() | ForEach-Object {Write-Host "$($_.Key): $($_.Value)"}; return $harmonicMap}
function GenerateWaveform {param ([string[]]$Tokens, [hashtable]$HarmonicMap) if (-Not $Tokens -or -Not $HarmonicMap) {Write-Host "Error: Invalid inputs to GenerateWaveform."; return $null}; $sampleRate = 44100; $duration = 1; $samples = @(0) * ($sampleRate * $duration); $progressStep = [math]::Floor($Tokens.Length / 10); foreach ($i in 0..($Tokens.Length - 1)) {if ($i % $progressStep -eq 0) {Write-Host "Progress: $([math]::Round(($i / $Tokens.Length) * 100, 0))% complete..."}; $frequency = $HarmonicMap[$Tokens[$i]]; for ($j = 0; $j -lt $sampleRate * $duration; $j++) {$time = $j / $sampleRate; $samples[$j] += [math]::Sin(2 * [math]::PI * $frequency * $time)}} return $samples}
function SaveAsWav {param ([string]$OutputFilePath, [single[]]$Samples, [hashtable]$HarmonicMap) Add-Type -AssemblyName System.Media; $wavFile = New-Object System.IO.FileStream($OutputFilePath, [System.IO.FileMode]::Create); $writer = New-Object System.IO.BinaryWriter($wavFile); $writer.Write([Text.Encoding]::ASCII.GetBytes("RIFF")); $writer.Write([int](36 + $Samples.Length * 2 + ($HarmonicMap.Count * 12))); $writer.Write([Text.Encoding]::ASCII.GetBytes("WAVEfmt ")); $writer.Write([int]16); $writer.Write([short]1); $writer.Write([short]1); $writer.Write([int]44100); $writer.Write([int](44100 * 2)); $writer.Write([short]2); $writer.Write([short]16); $writer.Write([Text.Encoding]::ASCII.GetBytes("data")); $writer.Write([int]($Samples.Length * 2)); foreach ($sample in $Samples) {$writer.Write([short]([math]::Round($sample * 32767)))} $writer.Write([Text.Encoding]::ASCII.GetBytes("HARM")); $writer.Write([int]($HarmonicMap.Count)); foreach ($key in $HarmonicMap.Keys) {$writer.Write([byte][int][char]$key); $writer.Write([int]$HarmonicMap[$key])} $writer.Close(); $wavFile.Close(); Write-Host "WAV file saved to $OutputFilePath"}
function ReadWav {param ([string]$InputFilePath) if (-Not (Test-Path $InputFilePath)) {Write-Host "Error: WAV file not found."; return $null}; Add-Type -AssemblyName System.Media; $wavFile = New-Object System.IO.FileStream($InputFilePath, [System.IO.FileMode]::Open); $reader = New-Object System.IO.BinaryReader($wavFile); $reader.BaseStream.Seek(44, [System.IO.SeekOrigin]::Begin); $samples = @(); while ($reader.BaseStream.Position -lt ($reader.BaseStream.Length - 4)) {$samples += [math]::Round($reader.ReadInt16() / 32767, 6)} $reader.BaseStream.Seek(-4, [System.IO.SeekOrigin]::End); $harmonicCount = $reader.ReadInt32(); $harmonicMap = @{}; for ($i = 0; $i -lt $harmonicCount; $i++) {$key = [char][byte]$reader.ReadByte(); $value = $reader.ReadInt32(); $harmonicMap[$key] = $value} $reader.Close(); $wavFile.Close(); return @($samples, $harmonicMap)}
function ReconstructText {param ([single[]]$Samples, [hashtable]$HarmonicMap) if (-Not $Samples -or -Not $HarmonicMap) {Write-Host "Error: Invalid inputs to ReconstructText."; return $null}; $reverseHarmonicMap = @{}; foreach ($key in $HarmonicMap.Keys) {$reverseHarmonicMap[$HarmonicMap[$key]] = $key} $reconstructedText = @(); foreach ($sample in $Samples) {$frequency = [math]::Round($sample * 44100); if ($reverseHarmonicMap.ContainsKey($frequency)) {$reconstructedText += $reverseHarmonicMap[$frequency]}} return -join $reconstructedText}
function CompressText {param ([string]$InputFilePath, [string]$OutputFilePath) if (-Not (Test-Path $InputFilePath)) {Write-Host "Error: Input file not found."; return}; Write-Host "Starting compression..."; $tokens = TokenizeText -InputFilePath $InputFilePath; if (-Not $tokens) {Write-Host "Error: Tokenization failed."; return}; Write-Host "Calculating token frequencies..."; $frequencyMap = GetTokenFrequencies -Tokens $tokens; if (-Not $frequencyMap) {Write-Host "Error: Frequency calculation failed."; return}; Write-Host "Assigning harmonics to tokens..."; $harmonicMap = AssignHarmonics -FrequencyMap $frequencyMap; if (-Not $harmonicMap) {Write-Host "Error: Harmonic assignment failed."; return}; Write-Host "Generating waveform..."; $samples = GenerateWaveform -Tokens $tokens -HarmonicMap $harmonicMap; if (-Not $samples) {Write-Host "Error: Waveform generation failed."; return}; Write-Host "Saving to WAV file..."; SaveAsWav -OutputFilePath $OutputFilePath -Samples $samples -HarmonicMap $harmonicMap; Write-Host "Compression complete. WAV file saved to $OutputFilePath"}
function DecompressText {param ([string]$InputFilePath, [string]$OutputFilePath) if (-Not (Test-Path $InputFilePath)) {Write-Host "Error: Compressed file not found."; return}; Write-Host "Starting decompression..."; Write-Host "Reading WAV file..."; $result = ReadWav -InputFilePath $InputFilePath; $samples = $result[0]; $harmonicMap = $result[1]; if (-Not $samples -or -Not $harmonicMap) {Write-Host "Error: Reading WAV file failed."; return}; Write-Host "Reconstructing original text..."; $reconstructedText = ReconstructText -Samples $samples -HarmonicMap $harmonicMap; if (-Not $reconstructedText) {Write-Host "Error: Text reconstruction failed."; return}; Set-Content -Path $OutputFilePath -Value $reconstructedText; Write-Host "Decompression complete. Text saved to $OutputFilePath"}
function MonitorResourceUsage {param ([ScriptBlock]$ScriptBlock) $startMemory = (Get-Process -Id $PID).WorkingSet64; $startTime = Get-Date; $ScriptBlock.Invoke(); $endMemory = (Get-Process -Id $PID).WorkingSet64; $endTime = Get-Date; $elapsedTime = $endTime - $startTime; Write-Host "Memory Used: $([math]::Round(($endMemory - $startMemory) / 1MB, 2)) MB"; Write-Host "Elapsed Time: $([math]::Round($elapsedTime.TotalSeconds, 2)) seconds"}
function TestCompressionSystem {Write-Host "Testing compression on enwik9..."; $testInputPath = "C:\Users\Owner\mascom\Core\Knowledge\enwik9\enwik9.txt"; $compressedPath = "compressed_output.wav"; $decompressedPath = "decompressed_output.txt"; Write-Host "Compressing..."; MonitorResourceUsage {CompressText -InputFilePath $testInputPath -OutputFilePath $compressedPath}; Write-Host "Decompressing..."; MonitorResourceUsage {DecompressText -InputFilePath $compressedPath -OutputFilePath $decompressedPath}; $original = (Get-Content -Path $testInputPath -Raw).Substring(0, 1000); $decompressed = Get-Content -Path $decompressedPath -Raw; if ($original -eq $decompressed) {Write-Host "Test passed: Original and decompressed files match."} else {Write-Host "Test failed: Original and decompressed files do not match."}}
TestCompressionSystem
